/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 crystal.glb
*/

import React, { useEffect, useLayoutEffect, useRef } from "react";
import {
  MeshReflectorMaterial,
  MeshTransmissionMaterial,
  useGLTF,
  useScroll,
} from "@react-three/drei";
import * as THREE from "three";

import { DoubleSide, MeshPhongMaterial, MeshPhysicalMaterial } from "three";
import { useControls } from "leva";
import gsap from "gsap";
import { useFrame } from "@react-three/fiber";

export function Crystal(props) {
  const { nodes, materials } = useGLTF("/model/crystal.glb");
  const groundRef = useRef();
  const { position, color } = useControls("big_crystal", {
    position: {
      value: [0, 0, 0],
      step: 0.1,
      min: -5,
      max: 20,
    },
    color: { value: "blue" },
  });
  const meshRefs = useRef([]);
  const scroll = useScroll();
  useEffect(() => {
    if (materials.M_Crystals) {
      materials.M_Crystals.roughness = 0.1;
      materials.M_Crystals.metalness = 1;
      materials.M_Crystals.transprent = true;
    }
  }, [materials.M_Crystals]);

  const crystalRef = useRef();
  const centeredCrystalRef = useRef();

  const tl = useRef();
  useLayoutEffect(() => {
    tl.current = gsap.timeline();

    tl.current.from(
      crystalRef.current.rotation,
      {
        duration: 3,
        y: Math.PI * 2,
      },
      0
    );

    tl.current.from(
      groundRef.current.position,
      {
        y: -20,
        duration: 1,
      },
      0
    );

    meshRefs.current.forEach((mesh, index) => {
      if (mesh) {
        tl.current.from(
          mesh.position,
          {
            duration: 2.5,
            ease: "power4.inout",
            x:
              index % 2 === 0
                ? mesh.position.x + (index + 1) * 10
                : mesh.position.x + (index + 1) * -10, // 예를 들어, x 위치를 기반으로 퍼뜨립니다. 다른 값을 조정할 수도 있습니다.
            y: mesh.position.y + (index + 1) * 15,
          },
          0
        );
      }
    });
  }, []);
  useFrame(() => {
    tl.current.seek(scroll.offset * tl.current.duration());
  });
  return (
    <group
      {...props}
      dispose={null}
      ref={crystalRef}
      castShadow={true}
      position={[0, 0, 2]}
    >
      <group rotation={[-Math.PI / 2, 0, 0]} scale={0.04}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            ref={(el) => (meshRefs.current[0] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0.geometry}
            material={materials.M_Crystals}
            position={[1.41, -0.38, 0.02]}
            scale={2.11}
          ></mesh>
          <mesh
            ref={(el) => (meshRefs.current[1] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0001.geometry}
            material={materials.M_Crystals}
            position={[-0.21, 0, 1.26]}
            scale={3.45}
          />
          <mesh
            ref={(el) => (meshRefs.current[2] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0002.geometry}
            material={materials.M_Crystals}
            position={[-1.08, 0.25, 2.21]}
            scale={3.34}
          />
          <mesh
            geometry={nodes.Crystals_SM_M_Crystals_0003.geometry}
            material={materials.M_Crystals}
            position={[0.02, -2.95, 0.36]}
            scale={4.47}
            ref={groundRef}
          ></mesh>
          <mesh
            ref={(el) => (meshRefs.current[3] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0004.geometry}
            material={materials.M_Crystals}
            position={[1.25, -1, -1.08]}
            scale={1.49}
          />
          <mesh
            ref={(el) => (meshRefs.current[4] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0005.geometry}
            material={materials.M_Crystals}
            position={[1.8, -1.21, 0.56]}
            scale={0.81}
          />
          <mesh
            ref={(el) => (meshRefs.current[5] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0006.geometry}
            material={materials.M_Crystals}
            position={[0.86, -1.28, 1.48]}
            scale={0.86}
          />
          <mesh
            ref={(el) => (meshRefs.current[6] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0007.geometry}
            material={materials.M_Crystals}
            position={[0.06, -0.81, -1.95]}
            scale={1.64}
          />
          <mesh
            ref={(el) => (meshRefs.current[7] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0008.geometry}
            material={materials.M_Crystals}
            position={[-1.51, 0.01, -1.69]}
            scale={2.96}
          />
          <mesh
            ref={(el) => (meshRefs.current[8] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0009.geometry}
            material={materials.M_Crystals}
            position={[1.19, -1.47, -0.22]}
            scale={0.47}
          />
          <mesh
            ref={(el) => (meshRefs.current[9] = el)}
            geometry={nodes.Crystals_SM_M_Crystals_0010.geometry}
            material={materials.M_Crystals}
            position={[-2.17, 0.42, 0.61]}
            scale={3.43}
          />
          <mesh
            geometry={nodes.Crystals_SM_M_Crystals_0011.geometry}
            material={materials.M_Crystals}
            position={[0.03, 1.21, 0.01]}
            scale={4.45}
            ref={centeredCrystalRef}
          ></mesh>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/model/crystal.glb");
